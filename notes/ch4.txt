Bit / Mod. Arithmetic Tricks
============================
x & 1 => isolate the LSB of x

x % 10 gives the least-significant decimal digit of x, if x is negative, so is
the digit

(1 << i) | (1 << j) => mask that will isolate the bits at indices i and j

Parity
======
- does a group of bits have an odd or even number of 1s ?
  - odd 1s => parity 1
  - even 1s => parity 0

- example
  - 1010 => parity 0
  - 1110 => parity 1


Two's Complement: Storing Signed Integers
=========================================
- n bits represent [-2^(n - 1), 2^(n - 1) - 1] (half the range goes to each of
  positive and negative, taking one off the top to represent zero)

- to represent -x, contstruct +x, invert each bit, and add one
  - cool result: the MSB acts as a sign bit, 0 => (+) and 1 => (-)

- addition and subtraction can be performed directly, ignoring overflow bits

- example: +2 + (-2)

  0 0 1 0
+ 1 1 1 0
  -------
1 0 0 0 0 = 0 (ignoring the overflow bit)


Misc. Primitive Types Information
=================================
- always cast to long long when inverting the sign of a variable of type int.
  Should the variable equal INT_MIN, it will overflow if you keep it as an int.

- literal suffixes: can be used to specify the type of a literal constant when
                    you want something other than the default

    example: 1L represents the value 1 in a long format (>= 32 bits)
